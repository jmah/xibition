#!/usr/bin/ruby

require 'rubygems'
require 'set'
require 'digest/sha1'
require 'escape'
require 'plist'


# Use the following in your git config:
# [diff "xibition"]
#   xfuncname = "^(@interface[ \t].*)$\n^[0-9 |-]*----\\+ (.+)$"
#   textconv = /path/to/this/script


filename = ARGV[0]
content_xml = %x(#{Escape.shell_command ['ibtool', '--all', filename]})
if content_xml.nil?
  fail "Error parsing #{filename}: '#{error}'"
end

plist = Plist::parse_xml content_xml
if not plist['com.apple.ibtool.errors'].nil?
  plist['com.apple.ibtool.errors'].each do |error|
    $stderr.puts "Error parsing #{filename}: '#{error['description']}'"
  end
  exit 1
end


#
# Utilities
#
$block_indent = ['']
def with_header(head, options={})
  options = {:indent => '    ', :prestrip => false}.merge options
  iputs head, options[:prestrip]
  $block_indent.push((options[:prestrip] ? $block_indent[-1].rstrip : $block_indent[-1]) + options[:indent])
  yield
  $block_indent.pop
end

def iputs(str='', prestrip=false)
  indent = $block_indent[-1]
  indent = indent.rstrip if prestrip
  puts((indent + str).rstrip)
end

class Hash
  def each_sorted_pair(*args)
    self.keys.sort.each {|key| yield key, self[key] }
  end
end

def display_label(obj_def)
  [obj_def['name'], obj_def['label']].compact.uniq.join(' - ')
end


#
# Classes
#
SkipClassNames = [/^NS/, /^IK/, /^OSA/, /^QC/,
  'FirstResponder', 'IBLibraryObjectTemplate',
  'ABPeoplePickerView', 'ABPersonView',
  'DRMSFFormatter', 'DiscRecordingPluginWidget',
  'PDFView', 'PDFThumbnailView',
  'QTCaptureView', 'QTMovieView',
  'WebView']

classdefs = plist['com.apple.ibtool.document.classes']
known_class_keys = ['class', 'superclass', 'outlets', 'actions']
classdefs.each_sorted_pair do |classkey, classdef|
  next if SkipClassNames.any? {|pat| pat === classdef['class'] }
  next if classdef['superclass'].nil?

  with_header "@interface #{classdef['class']} : #{classdef['superclass']}", :indent => '' do
    (classdef['outlets'] || {}).each_sorted_pair do |name, outletclass|
      iputs ['@property', 'IBOutlet', outletclass, (outletclass == 'id' ? '' : '*') + name].join(' ') + ';'
    end

    (classdef['actions'] || {}).each_sorted_pair do |sel, id|
      iputs "- (IBAction)#{sel}(#{id})sender;"
    end
  end
  iputs '@end'
  iputs
end
iputs


#
# Index objects and connections
#
$connections_by_source_id = Hash.new {|h,k| h[k] = [] }
plist['com.apple.ibtool.document.connections'].each_pair do |conn_id, conn_def|
  # The nib encodes the source of an action as the receiver; instead use the sender
  source_id = (conn_def['type'] == 'IBCocoaActionConnection') ? conn_def['destination-id'] : conn_def['source-id']
  $connections_by_source_id[source_id] << conn_def
end

$object_id_map = {}
plist['com.apple.ibtool.document.objects'].each do |obj_id, obj_def|
  i18n_def = plist['com.apple.ibtool.document.localizable-all'][obj_id] || {}
  $object_id_map[obj_id.to_i] = obj_def.merge i18n_def
end

hierarchy_def_stack = [] + plist['com.apple.ibtool.document.hierarchy']
until hierarchy_def_stack.empty?
  hier_def = hierarchy_def_stack.pop
  obj_def = $object_id_map[hier_def['object-id']]
  $object_id_map[hier_def['object-id']] = obj_def.merge(hier_def.merge({'children' => nil}))
  hierarchy_def_stack.concat(hier_def['children'] || [])
end


#
# Print objects
#
AttributesTreatedSeparately = Set.new %w[object-id custom-class name label ibShadowedToolTip frameOrigin frameSize children]
$needs_line = false
def describe_object(hier_def)
  obj_id = hier_def['object-id']
  obj_def = $object_id_map[obj_id]

  obj_id_str = obj_id.to_s.rjust(4)
  desc = "#{"-" * obj_id_str.length}+ "
  custom_class = obj_def['custom-class']
  desc << "(#{custom_class} *) " if custom_class and custom_class != 'FirstResponder'
  desc << display_label(obj_def)

  iputs if $needs_line; $needs_line = false
  with_header desc, :indent => "#{obj_id_str}| ", :prestrip => true do
    iputs "Attributes: #{attributes_sha1(obj_def)}"

    if obj_def['ibShadowedToolTip']
      iputs "ToolTip: #{obj_def['ibShadowedToolTip']}"
    end
    if obj_def['frameOrigin']
      iputs "{#{obj_def['frameOrigin']}, #{obj_def['frameSize']}}"
    end
    $needs_line = true

    $connections_by_source_id[obj_id].each do |conn_def|
      next unless conn_def['type'] == 'IBCocoaActionConnection'
      iputs if $needs_line; $needs_line = false
      iputs "-[(#{conn_def['source-label']}) #{conn_def['label']}]"
      $needs_line = true
    end
    $connections_by_source_id[obj_id].each do |conn_def|
      next unless conn_def['type'] == 'IBCocoaOutletConnection'
      iputs if $needs_line; $needs_line = false
      iputs "#{conn_def['label']} = #{conn_def['destination-label']}"
    end
    $connections_by_source_id[obj_id].each do |conn_def|
      next unless conn_def['type'] == 'IBBindingConnection'
      dest_id = conn_def['destination-id']
      iputs if $needs_line; $needs_line = false
      with_header "#{conn_def['binding']}: (#{dest_id}| #{display_label($object_id_map[dest_id])}).#{conn_def['keypath']}" do
        conn_def['binding-options'].each_sorted_pair do |option, value|
          iputs [option, value].join(' = ')
        end
      end
      $needs_line = true
    end

    (hier_def['children'] || []).each {|child_hier_def| describe_object(child_hier_def) }
  end
  $needs_line = true
end

def attributes_sha1(obj_def)
  attrs_for_hash = obj_def.select {|k,v| not AttributesTreatedSeparately.include? k }
  Digest::SHA1.hexdigest attrs_for_hash.sort_by {|pair| pair[0] }.inspect
end

plist['com.apple.ibtool.document.hierarchy'].each {|hier_def| describe_object(hier_def) }
